FROM: "Stephen J. Butler" <stephen.butler@csmining.org>
TO: Objective-C List <objc-language@lists.apple.com>
SUBJECT: Re: @synchronized scope strangeness

Your problem is simple...
On Fri, Apr 16, 2010 at 5:53 PM, Hamish Allan  wrote:
> @implementation NSPersistentStore (OTAdditions)
> - (NSNumber *)autoincrementingNumberForKey:(NSString *)key
> {
> Â  Â NSNumber *number;
> Â  Â @synchronized(self)
> Â  Â {
> Â  Â  Â  Â NSMutableDictionary *metadata = [[self metadata] mutableCopy];
>
> Â  Â  Â  Â // need to copy and autorelease the number because the original
> Â  Â  Â  Â // does not remain valid outside of the @synchronized block (why?!)
> Â  Â  Â  Â number = [[[metadata objectForKey:key] copy] autorelease];
If you don't somehow retain "number" here...
> Â  Â  Â  Â if (!number)
> Â  Â  Â  Â  Â  Â number = [NSNumber numberWithUnsignedLongLong:1];
> Â  Â  Â  Â [metadata setValue:[NSNumber
> numberWithUnsignedLongLong:([number unsignedLongLongValue] + 1)]
> forKey:key];
... it's released by the dictionary when you replace it with a new
value here. That's why you need the copy-autorelease. Or a retain
would work just as well, and then you could autorelease as you return
it (return [number autorelease]).
> Â  Â  Â  Â [self setMetadata:metadata];
Also, you never release the mutableCopy of metadata that you created.
Memory leak.
> Â  Â }
> Â  Â return number;
> }
 _______________________________________________
Do not post admin requests to the list. They will be ignored.
Objc-language mailing list      (Objc-language@lists.apple.com)
Help/Unsubscribe/Update your Subscription:
http://lists.apple.com/mailman/options/objc-language/mlsubscriber.tech%40csmining.org
This email sent to mlsubscriber.tech@csmining.org