FROM: Daniel Markarian <markarian@apple.com>
TO: websrvr <websrvr@macftphttp.serverbox.org>
SUBJECT: Re: auto mounting a partition with nobrowse

Hey Dale,
> In 10.6 it does show the nobrowse but in the left side of the finder window I can see the partition (it's grayed out) but only seems to do this if there are existing finder windows open, if all windows are closed then the partitions are not visible at all.
This is a "problem" that is above Disk Arbitration.  You have to take this up with the Finder by filing a bug.  It seems to me that it was intentional.  I do not see this as a problem in practice, since a user will never have a chance to open the partition if you always mount it nobrowse.
With regards to the interpretation of nobrowse on 10.5, if it differs from 10.6, you may wish to consider other avenues.  You can use noauto in /etc/fstab to prevent the mount altogether, and only the mount the partition in question on demand.
> Depending on the existence of the fstab file to do the hiding is a poor solution since I cannot guarantee the user will plug the drive only into systems that have it.
How does a daemon that talks to Disk Arbitration solve that problem on such systems?
You have to understand that Disk Arbitration is what handles /etc/fstab.  You can think of /etc/fstab as prerecorded instructions to save you from writing a daemon to talk to Disk Arbitration.  This also solves the problem of internal volumes that mount before your daemon is even loaded at boot.  It is in fact a more robust solution, but you have not come to realize the disadvantages of a daemon yet.
I doubt that a daemon will solve this problem.  You will achieve the very same thing, which is to mount it nobrowse.  Finder is welcome to interpret that as it likes, even if it does not meet your expectations.  You can certainly try to see if it makes a difference, but I doubt it will be fruitful.
> /* guessing due to lack of sample code */
We have no sample code using Disk Arbitration 2, unfortunately.  We do with Disk Arbitration 1, but you will want to avoid it like the plague.  Disk Arbitration 2 does have HeaderDoc by contrast.  Note that the fundamentals of Core Foundation are covered elsewhere.
Dan
Le 2010-05-13 Ã  02:29, websrvr a Ã©crit :
> 
> On May 12, 2010, at 21:20 PM, Daniel Markarian wrote:
> 
>> Hey Dale,
>> 
>> Does /sbin/mount show "nobrowse" on 10.6?
>> 
>> Dan
>> 
>> PS: You can run the 10.6 version of /sbin/mount on 10.5 to check the state of "nobrowse" on 10.5 as well.
> 
> Hey Dan,
> 
> The 10.6.2 version of mount  doesn't run in 10.5.6.
> 
> In 10.6 it does show the nobrowse but in the left side of the finder window I can see the partition (it's grayed out) but only seems to do this if there are existing finder windows open, if all windows are closed then the partitions are not visible at all.
> 
> Depending on the existence of the fstab file to do the hiding is a poor solution since I cannot guarantee the user will plug the drive only into systems that have it.
> 
> Using DiskArbitration seems to offer the results I need so I started coding a little test app but due to the lack of sample code I'm not sure I'm doing any of it properly since it segfaults when I use DADiskMountWithArguments().
> 
> Here's the code:
> 
> // test_mount.m
> // gcc -Wall -o test_mount test_mount.m -framework DiskArbitration -framework Foundation
> 
> #import 
> #import 
> 
> #define _NO_ARGS_		1
> 
> /* guessing due to lack of sample code */
> DADissenterRef
> MountDiskHidden(DADiskRef disk, void *context)
> {
> 	char const *CdiskName = DADiskGetBSDName(disk);
> 	NSString *diskName = [NSString stringWithUTF8String:CdiskName];
> 	NSRange s1s1NumberRange = NSMakeRange([diskName length] - 4, 4);
> 	DADissenterRef dissenter;
> 	char *type;
> 
> 	if([[diskName substringWithRange:s1s1NumberRange] isEqualToString:@"s1s1"]) /* it's our magic partition */
> 	{
> 
> #if _NO_ARGS_
> 		DADiskMount(disk,
> 					NULL,
> 					kDADiskMountOptionDefault,
> 					NULL,
> 					NULL);
> #else
> 		CFStringRef arguments = CFStringCreateWithCString(kCFAllocatorDefault, "nobrowse", kCFStringEncodingUTF8);
> 
> 		/* using this causes a segfault */
> 		DADiskMountWithArguments(disk,
> 								NULL,
> 								kDADiskMountOptionDefault,
> 								NULL,
> 								NULL,
> 								&arguments;);
> #endif
> 
> 		dissenter = DADissenterCreate(kCFAllocatorDefault,
> 									kDAReturnSuccess,
> 									CFSTR("mounted hidden"));
> 
> 		type = "mounted hidden";
> 	}
> 	else
> 	{
> 		DADiskMount(disk,
> 					NULL,
> 					kDADiskMountOptionDefault,
> 					NULL,
> 					NULL);
> 
> 		dissenter = DADissenterCreate(kCFAllocatorDefault,
> 									kDAReturnSuccess,
> 									CFSTR("mount not permitted"));
> 
> 		type = "mounted normal";
> 	}
> 
> 	printf("%s: %s\n", CdiskName, type);
> 
> 	return dissenter;
> }
> 
> /* This should really be daemonized but should suffice for test purposes */
> int
> main (int argc, const char * argv[])
> {
> 	NSAutoreleasePool *pool = [NSAutoreleasePool new];
> 	DAApprovalSessionRef session = DAApprovalSessionCreate(kCFAllocatorDefault);
> 
> 	if (!session)
> 	{
> 		fprintf(stderr, "failed to create Disk Arbitration session");
> 		goto out;
> 	}
> 
> 	DARegisterDiskMountApprovalCallback(session,
> 										NULL,  // matches all disk objects
> 										MountDiskHidden,
> 										NULL); // context
> 
> 	DAApprovalSessionScheduleWithRunLoop(session,
> 										 CFRunLoopGetCurrent(),
> 										 kCFRunLoopDefaultMode);
> 
> 	CFRunLoopRunInMode(kCFRunLoopDefaultMode,
> 						45 /* seconds */,
> 						false);
> 
> 	DAApprovalSessionUnscheduleFromRunLoop(session,
> 										 CFRunLoopGetCurrent(),
> 										 kCFRunLoopDefaultMode);
> 
> 	DAUnregisterApprovalCallback(session,
> 								MountDiskHidden,
> 								NULL);
> 
> out:
>   if (session)
> 		CFRelease(session);
> 
>    [pool release];
> 
> 	exit(0);
> }
> 
 _______________________________________________
Do not post admin requests to the list. They will be ignored.
Filesystem-dev mailing list      (Filesystem-dev@lists.apple.com)
Help/Unsubscribe/Update your Subscription:
http://lists.apple.com/mailman/options/filesystem-dev/mlsubscriber.tech%40csmining.org
This email sent to mlsubscriber.tech@csmining.org